diff --git a/src/cxxpool.h b/src/cxxpool.h
index 36ce36b..bc34572 100644
--- a/src/cxxpool.h
+++ b/src/cxxpool.h
@@ -11,6 +11,7 @@
 #include <queue>
 #include <utility>
 #include <functional>
+#include <tuple>
 #include <vector>
 #include <chrono>
 #include <cstddef>
@@ -23,7 +24,7 @@ namespace detail {
 template<typename Iterator>
 struct future_info {
     typedef typename std::iterator_traits<Iterator>::value_type future_type;
-    typedef typename std::result_of<decltype(&future_type::get)(future_type)>::type value_type;
+    typedef decltype(std::declval<future_type>().get()) value_type;
     static constexpr bool is_void = std::is_void<value_type>::value;
 };
 
@@ -211,14 +212,15 @@ public:
     // Constructor. No threads are launched
     thread_pool()
     : done_{false}, paused_{false}, threads_{}, tasks_{}, task_counter_{},
-      task_cond_var_{}, task_mutex_{}, thread_mutex_{}
+      task_cond_var_{}, task_mutex_{}, thread_mutex_{}, on_worker_start_{}
     {}
 
     // Constructor. Launches the desired number of threads. Passing 0 is
     // equivalent to calling the no-argument constructor
-    explicit thread_pool(std::size_t n_threads)
+    explicit thread_pool(std::size_t n_threads, std::function<void()> on_worker_start)
     : thread_pool{}
     {
+        on_worker_start_ = std::move(on_worker_start);
         if (n_threads > 0) {
             std::lock_guard<std::mutex> thread_lock(thread_mutex_);
             const auto n_target = threads_.size() + n_threads;
@@ -241,6 +243,10 @@ public:
         }
     }
 
+    explicit thread_pool(std::size_t n_threads)
+    : thread_pool(n_threads, nullptr)
+    {}
+
     // Destructor. Joins all threads launched. Waits for all running tasks
     // to complete
     ~thread_pool() {
@@ -299,8 +305,18 @@ public:
     template<typename Functor, typename... Args>
     auto push(std::size_t priority, Functor&& functor, Args&&... args) -> std::future<decltype(functor(args...))> {
         typedef decltype(functor(args...)) result_type;
+        using functor_type = typename std::decay<Functor>::type;
+        using args_tuple_type = std::tuple<typename std::decay<Args>::type...>;
+        auto bound_functor = functor_type(std::forward<Functor>(functor));
+        auto bound_args = args_tuple_type(std::forward<Args>(args)...);
         auto pack_task = std::make_shared<std::packaged_task<result_type()>>(
-                std::bind(std::forward<Functor>(functor), std::forward<Args>(args)...));
+                [bound_functor = std::move(bound_functor), bound_args = std::move(bound_args)]() mutable -> result_type {
+                    return std::apply(
+                            [&bound_functor](auto&&... unpacked_args) -> result_type {
+                                return std::invoke(bound_functor, std::forward<decltype(unpacked_args)>(unpacked_args)...);
+                            },
+                            std::move(bound_args));
+                });
         auto future = pack_task->get_future();
         {
             std::lock_guard<std::mutex> task_lock(task_mutex_);
@@ -339,6 +355,8 @@ public:
 private:
 
     void worker() {
+        if (on_worker_start_)
+            on_worker_start_();
         for (;;) {
             cxxpool::detail::priority_task task;
             {
@@ -376,6 +394,7 @@ private:
     std::condition_variable task_cond_var_;
     mutable std::mutex task_mutex_;
     mutable std::mutex thread_mutex_;
+    std::function<void()> on_worker_start_;
 };
 
 
